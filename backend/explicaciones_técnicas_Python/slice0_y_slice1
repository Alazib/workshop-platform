# Notas técnicas — Slice 0 y Slice 1



Este documento recopila explicaciones técnicas clave que han ido apareciendo en los Slices 0 y 1 del backend: el uso de default_factory, `@dataclass` vs `__init__`, y `Protocol`

---

## 1. `default_factory` vs valores por defecto normales

En las `dataclasses` de Python, los campos se definen así:

    @dataclass
    class Registration:
        id: int
        created_at: datetime
        confirmation_date: datetime | None

La pregunta es:
**¿qué diferencia hay entre…**

- `created_at: datetime = datetime.now()`
  y
- `created_at: datetime = field(default_factory=datetime.now)`?

Y también:
**¿por qué `confirmation_date: datetime | None = None` no necesita `default_factory`?**

### 1.1. Cuándo se evalúa cada cosa

- `datetime.now()` es **una llamada a función**.
- `datetime.now` (sin paréntesis) es **una referencia a la función**.

Cuando escribes:

    created_at: datetime = datetime.now()

esa llamada se ejecuta **una única vez**, cuando Python carga el módulo (cuando importas el fichero), no cada vez que creas una instancia de la clase.

En cambio, cuando escribes:

    created_at: datetime = field(default_factory=datetime.now)

`default_factory` recibe la función `datetime.now` y **la llamará cada vez que crees una nueva instancia** de la clase.

### 1.2. Ejemplo para ver el problema

Imagina este código:

    @dataclass
    class A:
        created_at: datetime = datetime.now()

    @dataclass
    class B:
        created_at: datetime = field(default_factory=datetime.now)

    a1 = A()
    time.sleep(1)
    a2 = A()

    b1 = B()
    time.sleep(1)
    b2 = B()

- En la clase `A`, **`created_at` tendrá el mismo valor** para `a1` y `a2`, porque `datetime.now()` se evaluó una sola vez cuando se definió la clase.
- En la clase `B`, `b1` y `b2` tendrán valores diferentes, porque `default_factory=datetime.now` se ejecuta en cada construcción de objeto.

### 1.3. Regla práctica

Usa `default_factory` cuando:

- El valor por defecto es **dinámico** (cambia en cada instancia), como:
  - `datetime.now`
  - `uuid.uuid4`
- O cuando el valor por defecto es un **objeto mutable** nuevo por instancia:
  - `default_factory=list`
  - `default_factory=dict`
  - `default_factory=set`

Ejemplos correctos:

    @dataclass
    class Example:
        created_at: datetime = field(default_factory=datetime.now)
        items: list[int] = field(default_factory=list)

Esto asegura que cada instancia tenga su propia fecha de creación y su propia lista.

### 1.4. ¿Por qué `None` NO usa `default_factory`?

`None` es:

- Un valor literal
- Inmutable
- No es una llamada a función

No necesitamos “fabricar” un `None` distinto por instancia. Simplemente queremos decir: “si no especifico nada, el valor es `None`”.

Por eso, escribir:

    confirmation_date: datetime | None = None

es totalmente correcto y suficiente.

En cambio, esto:

    confirmation_date: datetime | None = field(default_factory=None)

sería incorrecto, porque `default_factory` espera **algo que se pueda llamar como una función** (`callable`), y `None` no lo es. Intentar usarlo daría un error de tipo:

- `'NoneType' object is not callable`.

---

## 2. ¿Por qué usamos `@dataclass` en entidades y no en casos de uso?

### 2.1. Entidades de dominio: son datos + reglas

Una entidad del dominio, como `Session` o `Registration`, representa algo **del negocio**:

    @dataclass
    class Session:
        id: int
        workshop_id: int
        title: str
        starts_at: datetime
        ends_at: datetime
        capacity_max: int
        state: SessionState

        def can_accept_registrations(self) -> bool:
            return self.state == SessionState.PUBLISHED

Características de una entidad de dominio:

- Tiene **datos** (atributos) que describen un concepto del negocio.
- Puede tener **métodos** que aplican reglas de negocio a esos datos.
- No suele tener dependencias externas (no tiene repositorios dentro).
- Es natural querer:
  - Imprimirla para depurar.
  - Compararla (a veces).
  - Serializarla.

`@dataclass` está diseñado precisamente para este tipo de clases:

- Genera automáticamente:
  - `__init__` con todos los campos.
  - `__repr__` legible.
  - `__eq__` (opcionalmente, comparaciones).

Te ahorra boilerplate y te permite centrarte en las reglas de negocio, no en la “fontanería” del constructor.

### 2.2. Casos de uso: son servicios, no datos

Un caso de uso como `RegisterToSessionUseCase` **no representa un dato**, sino una **acción** del sistema:

    class RegisterToSessionUseCase:
        def __init__(
            self,
            session_repo: SessionRepository,
            registration_repo: RegistrationRepository,
        ) -> None:
            self.session_repo = session_repo
            self.registration_repo = registration_repo

        def execute(self, session_id: int, user_id: int) -> Registration:
            ...

Características de un caso de uso:

- Coordina pasos de aplicación:
  - Leer datos de repositorios.
  - Llamar a métodos del dominio.
  - Guardar cambios.
- Recibe **dependencias externas** (repositorios, servicios), no datos del negocio.
- No es un “objeto del dominio” que haya que almacenar, comparar o serializar.
- Es un **servicio de aplicación**, no una entidad.

Por eso **NO** usamos `@dataclass` aquí:

- No queremos que genere `__eq__`, `__repr__`, etc. para un servicio.
- No queremos tratar un caso de uso como un “dato” con atributos semánticos del negocio.
- Lo que tiene son **dependencias**, no “campos de dominio”.

### 2.3. Metáfora

- Una **entidad** es como una ficha de ajedrez: tiene color, tipo, posición.
- Un **caso de uso** es como “el turno del jugador”: qué pieza mueve, cuándo, con qué reglas.

Tiene sentido usar `@dataclass` para representar fichas (datos).
No tiene sentido usar `@dataclass` para representar “un turno” o “una jugada” como objeto de datos permanente.

---

## 3. ¿Por qué usamos `Protocol` para los repositorios?

En el dominio definimos puertos (interfaces) para que el caso de uso hable con la infraestructura sin conocer detalles de Django ni de la base de datos.

Ejemplo:

    from typing import Optional, Protocol
    from domain.entities.session import Session

    class SessionRepository(Protocol):
        def get_session_by_id(self, session_id: int) -> Optional[Session]:
            ...

        def save_session(self, session: Session) -> None:
            ...

### 3.1. ¿Qué es un `Protocol`?

Un `Protocol` es una forma de decir:

> “Cualquier clase que tenga estos métodos, con estas firmas, se considera un `SessionRepository`.”

Es lo que se llama **typing estructural**:

- No importa de qué clase hereda.
- Importa que **“se comporte”** como un repositorio (que tenga esos métodos).

Es la versión tipada del famoso “duck typing” de Python:

- “Si parece un pato, nada como un pato y hace cuac, es un pato.”

### 3.2. Qué gana el dominio con `Protocol`

En el caso de uso:

    class RegisterToSessionUseCase:
        def __init__(
            self,
            session_repo: SessionRepository,
            registration_repo: RegistrationRepository,
        ) -> None:
            self.session_repo = session_repo
            self.registration_repo = registration_repo

        def execute(self, session_id: int, user_id: int) -> Registration:
            session = self.session_repo.get_session_by_id(session_id)
            ...

El caso de uso solo sabe que:

- `session_repo` tiene un método `get_session_by_id`.
- `registration_repo` tiene un método `save_registration`, etc.

No sabe:

- Si por detrás hay Django ORM.
- Si hay una lista en memoria (para tests).
- Si hay una API externa.

Eso permite:

- Probar el caso de uso con repositorios **in-memory** (sin base de datos, sin Django).
- Cambiar la implementación de los repositorios sin tocar el caso de uso.
- Cumplir la idea de “puertos y adaptadores” de la arquitectura hexagonal.

### 3.3. Ejemplo de uso con dos implementaciones

1. **Implementación en memoria (para tests)**

    class InMemorySessionRepository:
        def __init__(self) -> None:
            self.sessions: dict[int, Session] = {}

        def get_session_by_id(self, session_id: int) -> Optional[Session]:
            return self.sessions.get(session_id)

        def save_session(self, session: Session) -> None:
            self.sessions[session.id] = session

2. **Implementación con Django ORM**

    class DjangoSessionRepository:
        def get_session_by_id(self, session_id: int) -> Optional[Session]:
            try:
                model = SessionModel.objects.get(id=session_id)
            except SessionModel.DoesNotExist:
                return None
            return model.to_domain()

        def save_session(self, session: Session) -> None:
            model = SessionModel.from_domain(session)
            model.save()

Ambas clases:

- No heredan explícitamente de `SessionRepository`.
- Pero **cumplen el protocolo** (tienen los métodos correctos).

Entonces, el caso de uso las puede recibir sin importarlas:

    # en tests
    repo = InMemorySessionRepository()

    # en producción con Django
    repo = DjangoSessionRepository()

En ambos casos:

    use_case = RegisterToSessionUseCase(
        session_repo=repo,
        registration_repo=another_repo,
    )

El caso de uso funciona igual, sin cambiar su código.

### 3.4. ¿Por qué no usamos directamente clases abstractas (`ABC`)?

Se podría usar `ABC` con `@abstractmethod`, pero:

- `Protocol` es más flexible:
  - No obliga a heredar explícitamente.
  - Encaja mejor con el estilo “duck typing” de Python.
- Para DDD/hexagonal en Python, los `Protocol` son una forma muy cómoda de expresar **interfaces de dominio**.

---

## 4. Resumen rápido para repaso

- **`default_factory`**
  - Úsalo cuando el valor por defecto es dinámico o mutable:
    - `field(default_factory=datetime.now)`
    - `field(default_factory=list)`
  - No lo uses para literales fijos como `None`, `0`, `True`, `"texto"`.

- **`@dataclass`**
  - Úsalo para entidades de dominio (datos + reglas).
  - No lo uses para casos de uso ni servicios (no representan datos, sino acciones).
  - Te ahorra escribir `__init__` y otros métodos estándar.

- **`Protocol`**
  - Se usa para definir contratos (puertos) que otras clases deben cumplir.
  - Permite que el dominio dependa de “interfaces” en lugar de implementaciones concretas.
  - Facilita la prueba del dominio con repositorios falsos y la sustitución de la infraestructura sin tocar el caso de uso.

