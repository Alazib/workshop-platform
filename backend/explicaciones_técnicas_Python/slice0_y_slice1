# Notas técnicas — Slice 0 y Slice 1

Este documento recopila explicaciones técnicas clave que han ido apareciendo en los Slices 0 y 1 del backend: el uso de default_factory, `@dataclass` vs `__init__`, `Protocol`, errores de dominio y herencia vs no herencia en repositorios in-memory.

---

## 1. `default_factory` vs valores por defecto normales

En las `dataclasses` de Python, los campos se definen así:

    @dataclass
    class Registration:
        id: int
        created_at: datetime
        confirmation_date: datetime | None

La pregunta es:
**¿qué diferencia hay entre…**

- `created_at: datetime = datetime.now()`
  y
- `created_at: datetime = field(default_factory=datetime.now)`?

Y también:
**¿por qué `confirmation_date: datetime | None = None` no necesita `default_factory`?**

### 1.1. Cuándo se evalúa cada cosa

- `datetime.now()` es **una llamada a función**.
- `datetime.now` (sin paréntesis) es **una referencia a la función**.

Cuando escribes:

    created_at: datetime = datetime.now()

esa llamada se ejecuta **una única vez**, cuando Python carga el módulo (cuando importas el fichero), no cada vez que creas una instancia de la clase.

En cambio, cuando escribes:

    created_at: datetime = field(default_factory=datetime.now)

`default_factory` recibe la función `datetime.now` y **la llamará cada vez que crees una nueva instancia** de la clase.

### 1.2. Ejemplo para ver el problema

    @dataclass
    class A:
        created_at: datetime = datetime.now()

    @dataclass
    class B:
        created_at: datetime = field(default_factory=datetime.now)

    a1 = A()
    time.sleep(1)
    a2 = A()

    b1 = B()
    time.sleep(1)
    b2 = B()

- En la clase `A`, **`created_at` tendrá el mismo valor** para `a1` y `a2`, porque `datetime.now()` se evaluó una sola vez cuando se definió la clase.
- En la clase `B`, `b1` y `b2` tendrán valores diferentes, porque `default_factory=datetime.now` se ejecuta en cada construcción de objeto.

### 1.3. Regla práctica

Usa `default_factory` cuando:

- El valor por defecto es **dinámico** (cambia en cada instancia), como:
  - `datetime.now`
  - `uuid.uuid4`
- O cuando el valor por defecto es un **objeto mutable** nuevo por instancia:
  - `default_factory=list`
  - `default_factory=dict`
  - `default_factory=set`

Ejemplos correctos:

    @dataclass
    class Example:
        created_at: datetime = field(default_factory=datetime.now)
        items: list[int] = field(default_factory=list)

### 1.4. ¿Por qué `None` NO usa `default_factory`?

`None` es:

- Un valor literal
- Inmutable
- No es una llamada a función

No necesitamos “fabricar” un `None` distinto por instancia.
Simplemente queremos decir: “si no especifico nada, el valor es `None`”.

Por eso, escribir:

    confirmation_date: datetime | None = None

es totalmente correcto.

En cambio, esto:

    confirmation_date: datetime | None = field(default_factory=None)

sería incorrecto, porque `default_factory` espera **algo que se pueda llamar como una función** (`callable`).

---

## 2. ¿Por qué usamos `@dataclass` en entidades y no en casos de uso?

### 2.1. Entidades de dominio: son datos + reglas

    @dataclass
    class Session:
        id: int
        workshop_id: int
        ...
        def can_accept_registrations(self) -> bool:
            return self.state == SessionState.PUBLISHED

Características:

- Representan **conceptos del negocio**.
- Tienen **datos** y **reglas de negocio**.
- No tienen dependencias externas.
- Son objetos “puros” del dominio.

`@dataclass` genera:

- `__init__`
- `__repr__`
- `__eq__`
- Manejo automático de los atributos

Ahorran mucha “fontanería”.

### 2.2. Casos de uso: NO son datos

    class RegisterToSessionUseCase:
        def __init__(self, session_repo, registration_repo):
            ...

Características:

- Son **servicios de aplicación**, no datos.
- Coordinan pasos (leer repos, aplicar reglas, guardar cambios).
- Tienen **dependencias externas** (repositorios).
- NO representan un concepto del dominio.

Por eso **NO deben usar `@dataclass`**:
no queremos que se traten como “datos”, porque no lo son.

Metáfora:
Una entidad es una **ficha de ajedrez**.
Un caso de uso es el **turno del jugador**: no se debe tratar como un objeto “almacenable”.

---

## 3. ¿Por qué usamos `Protocol` para los repositorios?

Ejemplo:

    class SessionRepository(Protocol):
        def get_session_by_id(self, session_id: int): ...
        def save_session(self, session: Session): ...

`Protocol` define un **contrato**:

> “Cualquier clase que tenga estos métodos es válida como SessionRepository.”

Esto permite:

- Independizar el dominio del framework (Django, SQLAlchemy…).
- Probar con repositorios **in-memory** sin necesidad de base de datos.
- Sustituir infraestructura sin tocar el caso de uso.
- Aplicar arquitectura hexagonal de verdad.

### Typing estructural
Python no mira herencia, mira **forma**:

    if la clase tiene los métodos → sirve

Por eso, incluso si NO heredas, el caso de uso lo acepta.

---

## 4. Errores de dominio personalizados y `DomainError`

En vez de usar errores genéricos (`ValueError`, `Exception`), el dominio define **sus propios errores**:

    class DomainError(Exception):
        pass

A primera vista parece inútil, pero es una **pieza clave**:

### 4.1. Es una “familia” de errores
Todas las excepciones del dominio heredan de esta clase:

    class SessionNotFound(DomainError): ...
    class SessionNotOpenForRegistration(DomainError): ...
    class SessionFull(DomainError): ...

Esto permite capturarlas TODAS en una sola instrucción:

    try:
        use_case.execute(...)
    except DomainError as e:
        return Response({"error": str(e)}, status=400)

### 4.2. ¿Por qué heredar si está vacía?

Porque **representa un tipo**, no una funcionalidad.

Metáfora:
Es el “apellido común” de todos los errores del dominio.
Si todos se apellidan *DomainError*, puedes filtrarlos juntos.

### 4.3. ¿Por qué pasamos argumentos a las excepciones?

Por ejemplo:

    raise SessionNotFound(session_id)

La clase recibe el ID para:

- construir un mensaje claro
- guardarlo internamente
- facilitar logs, debugging y respuestas HTTP

Ejemplo:

    class SessionNotFound(DomainError):
        def __init__(self, session_id):
            message = f"La sesión {session_id} no existe."
            super().__init__(message)
            self.session_id = session_id

Cuando haces:

    except SessionNotFound as e:
        e.session_id  # contiene el ID que falló

### 4.4. ¿Por qué usamos super().__init__(message)?

- Llama al constructor del padre (`Exception`)
- Registra el mensaje internamente
- Permite que `str(e)` muestre el mensaje

Sin esta llamada, la excepción saldría SIN mensaje.

---

## 5. ¿Por qué `InMemorySessionRepository` puede heredar o NO heredar del `Protocol`?

Ejemplo con herencia:

    class InMemorySessionRepository(SessionRepository):
        ...

Ejemplo sin herencia:

    class InMemorySessionRepository:
        def get_session_by_id(...):
        def save_session(...):

### 5.1. Con Protocol **NO ES NECESARIO HEREDAR**

La herencia NO aporta funcionalidad.
El `Protocol` solo define un **contrato estructural**:

> “Si tienes los métodos necesarios, eres válido.”

Por tanto, esto funciona igual:

    repo = InMemorySessionRepository()

Aunque no herede de nada.

### 5.2. ¿Qué aporta heredar explícitamente?

Solo **intención y documentación**:

- El desarrollador leyendo el código entiende: “esta clase implementa el puerto”.
- Algunas herramientas de análisis estático (mypy) pueden ser más estrictas y detectar errores antes.

### 5.3. ¿Qué pasa si NO heredas?

**Nada.**
Es totalmente válido, porque Python usa **typing estructural**:

- Si la clase tiene los métodos → cumple el protocolo.
- La herencia NO es obligatoria como en Java o C#.

### 5.4. Metáfora clara
Un `Protocol` es un “contrato en PDF”.
Tu clase puede:

- Poner un sello diciendo “yo implemento este contrato” → heredar
- O simplemente cumplir el contrato sin decirlo → no heredar

Ambas opciones son válidas.

---

## 6. Resumen rápido para repaso

- **`default_factory`** → para valores dinámicos o mutables.
- **`@dataclass`** → para entidades (datos + reglas), NO para casos de uso.
- **`Protocol`** → define contratos; heredar es opcional.
- **`DomainError`** → clase base para capturar todos los errores del dominio.
- **Excepciones personalizadas** → transmiten contexto claro (session_id, etc.).
- **Repos in-memory** → funcionan aunque NO hereden del protocolo.

