# Notas técnicas — Slice 0 y Slice 1

Este documento recopila explicaciones técnicas clave que han ido apareciendo en los Slices 0 y 1 del backend.

## 1. `default_factory` vs valores por defecto normales

En las `dataclasses` de Python, los campos se definen así:

    @dataclass
    class Registration:
        id: int
        created_at: datetime
        confirmation_date: datetime | None

La pregunta es:
**¿qué diferencia hay entre…**

- `created_at: datetime = datetime.now()`
  y
- `created_at: datetime = field(default_factory=datetime.now)`?

Y también:
**¿por qué `confirmation_date: datetime | None = None` no necesita `default_factory`?**

### 1.1. Cuándo se evalúa cada cosa

- `datetime.now()` es **una llamada a función**.
- `datetime.now` (sin paréntesis) es **una referencia a la función**.

Cuando escribes:

    created_at: datetime = datetime.now()

esa llamada se ejecuta **una única vez**, cuando Python carga el módulo (cuando importas el fichero), no cada vez que creas una instancia de la clase.

En cambio, cuando escribes:

    created_at: datetime = field(default_factory=datetime.now)

`default_factory` recibe la función `datetime.now` y **la llamará cada vez que crees una nueva instancia** de la clase.

### 1.2. Ejemplo para ver el problema

    @dataclass
    class A:
        created_at: datetime = datetime.now()

    @dataclass
    class B:
        created_at: datetime = field(default_factory=datetime.now)

    a1 = A()
    time.sleep(1)
    a2 = A()

    b1 = B()
    time.sleep(1)
    b2 = B()

- En la clase `A`, **`created_at` tendrá el mismo valor** para `a1` y `a2`, porque `datetime.now()` se evaluó una sola vez cuando se definió la clase.
- En la clase `B`, `b1` y `b2` tendrán valores diferentes, porque `default_factory=datetime.now` se ejecuta en cada construcción de objeto.

### 1.3. Regla práctica

Usa `default_factory` cuando:

- El valor por defecto es **dinámico** (cambia en cada instancia), como:
  - `datetime.now`
  - `uuid.uuid4`
- O cuando el valor por defecto es un **objeto mutable** nuevo por instancia:
  - `default_factory=list`
  - `default_factory=dict`
  - `default_factory=set`

Ejemplos correctos:

    @dataclass
    class Example:
        created_at: datetime = field(default_factory=datetime.now)
        items: list[int] = field(default_factory=list)

### 1.4. ¿Por qué `None` NO usa `default_factory`?

`None` es:

- Un valor literal
- Inmutable
- No es una llamada a función

No necesitamos “fabricar” un `None` distinto por instancia.
Simplemente queremos decir: “si no especifico nada, el valor es `None`”.

Por eso, escribir:

    confirmation_date: datetime | None = None

es totalmente correcto.

En cambio, esto:

    confirmation_date: datetime | None = field(default_factory=None)

sería incorrecto, porque `default_factory` espera **algo que se pueda llamar como una función** (`callable`).

---

## 2. ¿Por qué usamos `@dataclass` en entidades y no en casos de uso?

### 2.1. Entidades de dominio: son datos + reglas

    @dataclass
    class Session:
        id: int
        workshop_id: int
        ...
        def can_accept_registrations(self) -> bool:
            return self.state == SessionState.PUBLISHED

Características:

- Representan **conceptos del negocio**.
- Tienen **datos** y **reglas de negocio**.
- No tienen dependencias externas.
- Son objetos “puros” del dominio.

`@dataclass` genera:

- `__init__`
- `__repr__`
- `__eq__`
- Manejo automático de los atributos

Ahorran mucha “fontanería”.

### 2.2. Casos de uso: NO son datos

    class RegisterToSessionUseCase:
        def __init__(self, session_repo, registration_repo):
            ...

Características:

- Son **servicios de aplicación**, no datos.
- Coordinan pasos (leer repos, aplicar reglas, guardar cambios).
- Tienen **dependencias externas** (repositorios).
- NO representan un concepto del dominio.

Por eso **NO deben usar `@dataclass`**:
no queremos que se traten como “datos”, porque no lo son.

Metáfora:
Una entidad es una **ficha de ajedrez**.
Un caso de uso es el **turno del jugador**: no se debe tratar como un objeto “almacenable”.

---

## 3. ¿Por qué usamos `Protocol` para los repositorios?

        class RegisterToSessionUseCase:
    def __init__(
        self, session_repo: SessionRepository, registration_repo: RegistrationRepository
    ) -> None:
        self.session_repo = session_repo
        self.registration_repo = registration_repo

    def execute(self, session_id: int, user_id: int) -> Registration:
        session = self.session_repo.get_session_by_id(session_id)
        if session is None:
            raise SessionNotFound(session_id)

            ETC
            ETC

Al caso de uso le paso en el constructor los objetos: "sesion_repo" del tipo "SessionRepository" y "registration_repo" del tipo "RegistrationRepository". Estos dos tipos (que a su vez son interfaces)
heredaron de "Protocol" (tienen tipado estructural, basado en la forma de los objetos. Diferente a la clásica herencia nominal). Esto quiere decir que, por ejemplo, la interfaz "SessionRepository" dice:
cualquier cosa que tenga mis métodos (mi estructura) es de mi mismo tipo. Por tanto, cualquier objeto "session_repo" que tenga los dos métodos de "SessionRepository" sera reconocido como tal tipo.
De esta manera podemos pasar, por ejemplo, un DjangoSessionRepository con los métodos de SessionRepository pero ya implementados en una tecnología concreta. De este modo, mantemos el caso de uso
agnóstico de cualquier tecnología (pues SessionRepository solo tiene el nombre de los métodos pero están vacíos, sin implementar) y DjangoSessionRepository (o cualquier otro repositorio de la capa
de infrastructura) traerá los mismos métodos pero ya implementados.



    class SessionRepository(Protocol):
        def get_session_by_id(self, session_id: int): ...
        def save_session(self, session: Session): ...

`Protocol` define un **contrato**:

> “Cualquier clase que tenga estos métodos es válida como SessionRepository.”

Esto permite:

- Independizar el dominio del framework (Django, SQLAlchemy…).
- Probar con repositorios **in-memory** sin necesidad de base de datos.
- Sustituir infraestructura sin tocar el caso de uso.
- Aplicar arquitectura hexagonal de verdad.

### Typing estructural
Python no mira herencia, mira **forma**:

    si la clase tiene los mismos métodos → sirve

Por eso, incluso si NO heredas, el caso de uso lo acepta.

---

## 4. Errores de dominio personalizados y `DomainError`

En vez de usar errores genéricos (`ValueError`, `Exception`), el dominio define **sus propios errores**:

    class DomainError(Exception):
        pass

A primera vista parece inútil, pero es una **pieza clave**:

### 4.1. Es una “familia” de errores
Todas las excepciones del dominio heredan de esta clase:

    class SessionNotFound(DomainError): ...
    class SessionNotOpenForRegistration(DomainError): ...
    class SessionFull(DomainError): ...

Esto permite capturarlas TODAS en una sola instrucción:

    try:
        use_case.execute(...)
    except DomainError as e:
        return Response({"error": str(e)}, status=400)

### 4.2. ¿Por qué heredar si está vacía?

Porque **representa un tipo**, no una funcionalidad.

Metáfora:
Es el “apellido común” de todos los errores del dominio.
Si todos se apellidan *DomainError*, puedes filtrarlos juntos.

### 4.3. ¿Por qué pasamos argumentos a las excepciones?

Por ejemplo:

    raise SessionNotFound(session_id)

La clase recibe el ID para:

- construir un mensaje claro
- guardarlo internamente
- facilitar logs, debugging y respuestas HTTP

Ejemplo:

    class SessionNotFound(DomainError):
        def __init__(self, session_id):
            message = f"La sesión {session_id} no existe."
            super().__init__(message)
            self.session_id = session_id

Cuando haces:

    except SessionNotFound as e:
        e.session_id  # contiene el ID que falló

### 4.4. ¿Por qué usamos super().__init__(message)?

- Llama al constructor del padre (`Exception`)
- Registra el mensaje internamente
- Permite que `str(e)` muestre el mensaje

Sin esta llamada, la excepción saldría SIN mensaje.

---

## 5. ¿Qué son los repositorios In Memory y por qué `InMemorySessionRepository` puede heredar o NO heredar del `Protocol`?

Un repositorio es un objeto que desde el dominio parece ser una colección de entidades (sesiones, registros, etc):

    session = session_repo.get_session_by_id(1)
    session_repo.save_session(session)

pero cuyo contenido, en realidad, se está guardando en un almacenamiento externo (BD, API, ficheros...) pues está operando en
la infraestructura: ejecutar SQL, guardar un modelo Django, llamar una API, escribir un fichero, etc.

Los repositorios, normalmente, sólo tienen métodos. Dichos métodos serán operaciones de lectura/escritura sobre una colección
del dominio (get, lis_all, save, delete, etc). Los repositorios *in-memory* sí pueden tener atributos (dicionarios que simular una BD, contadores, etc)

Los repositorios *in-memory* son implementaciones “falsas” de los puertos del dominio.
Simulan lo que haría la infraestructura real (base de datos, Django ORM), pero usando únicamente estructuras de datos de Python — normalmente diccionarios. Sin servidor. Sin migraciones. Sin bases de datos. Sin modelos Django.

Ejemplo conceptual:

- `DjangoSessionRepository` → Adaptador REAL (usa la BD)
- `InMemorySessionRepository` → Adaptador FALSO (usa un dict)

Ambos cumplen el mismo **contrato** (`SessionRepository`), pero uno es real y otro es simulado.

Esto permite ejecutar casos de uso sin infraestructura, lo cual es ideal para tests rápidos y para la arquitectura hexagonal.

---

### 5.1. ¿Por qué estos repos in-memory son adaptadores?

En arquitectura hexagonal:

- El **dominio** depende de puertos (interfaces) que no implementan métodos.
- La **infraestructura** crea adaptadores que implementan esos puertos (implementan los métodos con infrastructura concreta: Django, HTTP, SQL, etc)

Ejemplo:

    SessionRepository (puerto)
         ▲
         │
    ┌────┴──────────────────────────────┐
    │                                   │
    DjangoSessionRepository       InMemorySessionRepository
 (adaptador real, ORM)        (adaptador falso, tests / desarrollo)

Ambos ofrecen los mismos métodos:

- `get_session_by_id`
- `save_session`

pero los ejecutan de forma diferente.

El caso de uso no nota la diferencia porque solo depende del **puerto**, no de la implementación.


| Infraestructura (real) | In-Memory (falso) |
| ---------------------- | ----------------- |
| Django ORM             | Diccionarios      |
| SQL                    | Listas Python     |
| Guardar modelo         | Guardar objeto    |
| Búsqueda por ID        | Buscar en dict    |
| Autoincrement ID       | Counter en Python |


---

### 5.2. Con `Protocol` el adaptador NO necesita heredar del puerto

El `Protocol` define una interfaz estructural:

> “Si una clase tiene estos métodos con estas firmas, ya cumple el contrato”.

Eso significa que esta clase:

    class InMemorySessionRepository:
        def get_session_by_id(self, session_id):
            ...
        def save_session(self, session):
            ...

YA cumple el contrato del protocolo **sin heredar nada**.

Python no exige herencia explícita como Java, C# o PHP.
Solo exige que la clase **tenga los métodos adecuados**.

Este mecanismo se llama **typing estructural** o “duck typing tipado”:

> Si camina como un pato y hace cuac como un pato, es un pato.

---

### 5.3. Entonces, ¿por qué A VECES heredamos del protocolo?

Principalmente por **intención y claridad visual**.

Ejemplo:

    class InMemorySessionRepository(SessionRepository):
        ...

Esto le dice al lector:

> “Esta clase implementa explícitamente el puerto `SessionRepository`.”

No cambia el comportamiento, no añade métodos, no ejecuta lógica del padre.
Solo sirve como **declaración de intención**.

Además:

- Ayuda a herramientas estáticas (mypy, pyright) a detectar errores de firma.
- Hace más evidente la relación adaptador → puerto.

Pero **NO ES OBLIGATORIO**.

---

### 5.4. ¿Qué pasa si no heredo?

Respuesta: **Nada. Funciona igual.**

    class InMemorySessionRepository:
        def get_session_by_id(self, session_id):
            ...
        def save_session(self, session):
            ...

El caso de uso podrá recibir esta clase exactamente igual:

    repo = InMemorySessionRepository()
    use_case = RegisterToSessionUseCase(repo, ...)

Porque cumple el contrato del protocolo al tener los métodos adecuados.

---

### 5.5. Comparación visual: herencia vs no herencia

**Con herencia (explícito, más declarativo):**

    class InMemorySessionRepository(SessionRepository):
        def get_session_by_id(self, session_id):
            return self._sessions.get(session_id)

        def save_session(self, session):
            self._sessions[session.id] = session

**Sin herencia (más estilo Python, más flexible):**

    class InMemorySessionRepository:
        def get_session_by_id(self, session_id):
            return self._sessions.get(session_id)

        def save_session(self, session):
            self._sessions[session.id] = session

Ambas versiones son 100% válidas.
La herencia solo cambia **cómo se lee el código**, no cómo funciona.



Un `Protocol` es como una **carta de requisitos** que dice:

- Debe tener método A.
- Debe tener método B.

Para cumplirla, puedes:

1. **Firmar la carta (heredar del protocolo)**
   → Más explícito, más formal.

2. **Cumplir la carta sin firmarla (no heredar)**
   → Python lo permite, mientras tengas los métodos adecuados.

Ambas formas son válidas.
La elección depende de estilo y claridad.



---
## 6. IDs de las entidades: dominio vs Django ORM ¿por qué la entidad del dominio no recibe el id del modelo?

### 6.1. Las tres piezas y su responsabilidad (visión general)

En arquitectura hexagonal, solemos tener:

1) Dominio (Python puro)
- Entidades como `Session` (dataclass)
- Reglas de negocio (máquinas de estado, invariantes)
- No sabe nada de Django ni de base de datos

2) Infraestructura Django (ORM)
- Modelos como `SessionModel(models.Model)`
- Representan filas en tablas de la BD
- Django Admin y el ORM trabajan directamente con esto

3) Repositorio Django (adaptador)
- `DjangoSessionRepository`
- Traduce entre:
  - `SessionModel` ↔ `Session`
- Es quien toca el ORM y, por tanto, quien realmente persiste en BD

Regla:
- Dominio decide reglas.
- ORM decide persistencia.
- Repositorio traduce entre ambos.

### 6.2. ¿Quién crea el id: Django o la base de datos?

Hay dos niveles del mismo mecanismo.

- Django “crea” el campo `id` en el modelo (si no lo declaras, Django añade un `AutoField/BigAutoField`).
- La base de datos “crea” el valor numérico del id (autoincrement) cuando se inserta una fila.
- Django, tras el INSERT, recoge el id generado y lo coloca en `model.id`.

Ejemplo:
- Django decide que la tabla tendrá una columna `id`.
- La BD decide que el nuevo registro tendrá `id=42`.
- Django te entrega `model.id == 42`.

### 6.3. Caso A: crear una sesión desde Django Admin (no hay problema con el id)

Flujo simplificado:

Paso 1) Admin rellena el formulario para `SessionModel`.
Paso 2) Pulsa “Save”.
Paso 3) Django crea un `SessionModel(...)` y llama a `model.save()`.
Paso 4) La BD inserta la fila y genera un id (por ejemplo, 42).
Paso 5) Django actualiza `model.id` con 42.

Aquí el dominio NO participa.
- No se crea `Session(...)` del dominio.
- No hay caso de uso de dominio.
- Por tanto, no existe “un objeto de dominio que necesite enterarse del id”.

Conclusión:
- Crear sesiones desde Admin está bien para MVP y pruebas.
- No aparece el problema de “el dominio no recibe el id” porque el dominio no ha creado nada.

### 6.4. Caso B: crear una sesión desde un caso de uso (aquí sí hay problema con el id)

Imaginemos un endpoint futuro:
POST /sessions

Paso 1) Llega la petición HTTP.
Paso 2) La vista crea el caso de uso `CreateSessionUseCase(...)`.
Paso 3) El caso de uso construye una entidad de dominio (en memoria):
    session = Session(
        id=0,  # o None, indicando “no persistida”
        workshop_id=1,
        title="Curso de acuarela",
        starts_at=...,
        ends_at=...,
        capacity_max=20,
        status=SessionStatus.DRAFT,
    )

Paso 4) El caso de uso manda persistir:
    session_repo.save_session(session)

Paso 5) El repositorio traduce al ORM:
    model = SessionModel()
    model.title = session.title
    model.status = session.status.value
    ...
    model.save()

Paso 6) La BD genera el id (ej: 42) y Django deja:
    model.id == 42

Problema:
- Si `save_session` devuelve `None`, el caso de uso sigue teniendo el objeto `session` original.
- Ese objeto aún tiene:
    session.id == 0
- Pero en la BD la sesión real es:
    id == 42

¿Por qué puede ser un problema?
Porque el caso de uso suele necesitar uno de estos:

- Devolver al cliente el id real en el JSON
- Crear inmediatamente entidades relacionadas que necesitan ese id (p.ej. una “primera inscripción”, un evento, un log, etc.)
- Encadenar operaciones en el mismo flujo

Si el dominio no conoce el id real, se queda “desconectado” del registro persistido.

### 6.5.  ¿Cómo se soluciona correctamente?

#### Solución 1 (más común): que `save(...)` devuelva la entidad persistida
Cambiar el contrato del repositorio para devolver una entidad con el id correcto:

    def save_session(self, session: Session) -> Session:
        model = SessionModel()
        ...
        model.save()
        return self._to_domain(model)  # aquí ya viene id=model.id

Así el caso de uso hace:

    session = session_repo.save_session(session)
    return session

Ventaja:
- No se necesita otra query “recuperar de BD”: el id ya está en `model.id` tras `save()`.

#### Solución 2 (más DDD “puro”): el dominio genera el id
Por ejemplo usando UUID:
- La entidad se crea con un id ya definitivo.
- El repositorio solo persiste ese id.
- Es más avanzado y no hace falta para el MVP.

### 6.6.  Resumen práctico:

- En Slice 1, las sesiones se crean desde admin → no hay problema.
- El problema del id aparece cuando:
  - una entidad se crea en dominio (memoria),
  - se persiste en BD,
  - y se necesita devolver/usar el id inmediatamente.
- Por ello ya se ha aplicado a `Registration`:
  - `save_registration(...)` debe devolver la entidad persistida con `id` real,
  - porque el caso de uso devuelve una `Registration` al endpoint.

Regla:
- Si el caso de uso va a devolver o seguir usando la entidad tras guardarla, el repositorio debe devolver la entidad persistida (con id correcto).



