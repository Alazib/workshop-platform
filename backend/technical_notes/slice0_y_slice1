# Notas técnicas — Slice 0 y Slice 1

Este documento recopila explicaciones técnicas clave que han ido apareciendo en los Slices 0 y 1 del backend.

## 1. `default_factory` vs valores por defecto normales

En las `dataclasses` de Python, los campos se definen así:

    @dataclass
    class Registration:
        id: int
        created_at: datetime
        confirmation_date: datetime | None

La pregunta es:
**¿qué diferencia hay entre…**

- `created_at: datetime = datetime.now()`
  y
- `created_at: datetime = field(default_factory=datetime.now)`?

Y también:
**¿por qué `confirmation_date: datetime | None = None` no necesita `default_factory`?**

### 1.1. Cuándo se evalúa cada cosa

- `datetime.now()` es **una llamada a función**.
- `datetime.now` (sin paréntesis) es **una referencia a la función**.

Cuando escribes:

    created_at: datetime = datetime.now()

esa llamada se ejecuta **una única vez**, cuando Python carga el módulo (cuando importas el fichero), no cada vez que creas una instancia de la clase.

En cambio, cuando escribes:

    created_at: datetime = field(default_factory=datetime.now)

`default_factory` recibe la función `datetime.now` y **la llamará cada vez que crees una nueva instancia** de la clase.

### 1.2. Ejemplo para ver el problema

    @dataclass
    class A:
        created_at: datetime = datetime.now()

    @dataclass
    class B:
        created_at: datetime = field(default_factory=datetime.now)

    a1 = A()
    time.sleep(1)
    a2 = A()

    b1 = B()
    time.sleep(1)
    b2 = B()

- En la clase `A`, **`created_at` tendrá el mismo valor** para `a1` y `a2`, porque `datetime.now()` se evaluó una sola vez cuando se definió la clase.
- En la clase `B`, `b1` y `b2` tendrán valores diferentes, porque `default_factory=datetime.now` se ejecuta en cada construcción de objeto.

### 1.3. Regla práctica

Usa `default_factory` cuando:

- El valor por defecto es **dinámico** (cambia en cada instancia), como:
  - `datetime.now`
  - `uuid.uuid4`
- O cuando el valor por defecto es un **objeto mutable** nuevo por instancia:
  - `default_factory=list`
  - `default_factory=dict`
  - `default_factory=set`

Ejemplos correctos:

    @dataclass
    class Example:
        created_at: datetime = field(default_factory=datetime.now)
        items: list[int] = field(default_factory=list)

### 1.4. ¿Por qué `None` NO usa `default_factory`?

`None` es:

- Un valor literal
- Inmutable
- No es una llamada a función

No necesitamos “fabricar” un `None` distinto por instancia.
Simplemente queremos decir: “si no especifico nada, el valor es `None`”.

Por eso, escribir:

    confirmation_date: datetime | None = None

es totalmente correcto.

En cambio, esto:

    confirmation_date: datetime | None = field(default_factory=None)

sería incorrecto, porque `default_factory` espera **algo que se pueda llamar como una función** (`callable`).

---

## 2. ¿Por qué usamos `@dataclass` en entidades y no en casos de uso?

### 2.1. Entidades de dominio: son datos + reglas

    @dataclass
    class Session:
        id: int
        workshop_id: int
        ...
        def can_accept_registrations(self) -> bool:
            return self.state == SessionState.PUBLISHED

Características:

- Representan **conceptos del negocio**.
- Tienen **datos** y **reglas de negocio**.
- No tienen dependencias externas.
- Son objetos “puros” del dominio.

`@dataclass` genera:

- `__init__`
- `__repr__`
- `__eq__`
- Manejo automático de los atributos

Ahorran mucha “fontanería”.

### 2.2. Casos de uso: NO son datos

    class RegisterToSessionUseCase:
        def __init__(self, session_repo, registration_repo):
            ...

Características:

- Son **servicios de aplicación**, no datos.
- Coordinan pasos (leer repos, aplicar reglas, guardar cambios).
- Tienen **dependencias externas** (repositorios).
- NO representan un concepto del dominio.

Por eso **NO deben usar `@dataclass`**:
no queremos que se traten como “datos”, porque no lo son.

Metáfora:
Una entidad es una **ficha de ajedrez**.
Un caso de uso es el **turno del jugador**: no se debe tratar como un objeto “almacenable”.

---

## 3. ¿Por qué usamos `Protocol` para los repositorios?

        class RegisterToSessionUseCase:
    def __init__(
        self, session_repo: SessionRepository, registration_repo: RegistrationRepository
    ) -> None:
        self.session_repo = session_repo
        self.registration_repo = registration_repo

    def execute(self, session_id: int, user_id: int) -> Registration:
        session = self.session_repo.get_session_by_id(session_id)
        if session is None:
            raise SessionNotFound(session_id)

            ETC
            ETC

Al caso de uso le paso en el constructor los objetos: "sesion_repo" del tipo "SessionRepository" y "registration_repo" del tipo "RegistrationRepository". Estos dos tipos (que a su vez son interfaces)
heredaron de "Protocol" (tienen tipado estructural, basado en la forma de los objetos. Diferente a la clásica herencia nominal). Esto quiere decir que, por ejemplo, la interfaz "SessionRepository" dice:
cualquier cosa que tenga mis métodos (mi estructura) es de mi mismo tipo. Por tanto, cualquier objeto "session_repo" que tenga los dos métodos de "SessionRepository" sera reconocido como tal tipo.
De esta manera podemos pasar, por ejemplo, un DjangoSessionRepository con los métodos de SessionRepository pero ya implementados en una tecnología concreta. De este modo, mantemos el caso de uso
agnóstico de cualquier tecnología (pues SessionRepository solo tiene el nombre de los métodos pero están vacíos, sin implementar) y DjangoSessionRepository (o cualquier otro repositorio de la capa
de infrastructura) traerá los mismos métodos pero ya implementados.



    class SessionRepository(Protocol):
        def get_session_by_id(self, session_id: int): ...
        def save_session(self, session: Session): ...

`Protocol` define un **contrato**:

> “Cualquier clase que tenga estos métodos es válida como SessionRepository.”

Esto permite:

- Independizar el dominio del framework (Django, SQLAlchemy…).
- Probar con repositorios **in-memory** sin necesidad de base de datos.
- Sustituir infraestructura sin tocar el caso de uso.
- Aplicar arquitectura hexagonal de verdad.

### Typing estructural
Python no mira herencia, mira **forma**:

    si la clase tiene los mismos métodos → sirve

Por eso, incluso si NO heredas, el caso de uso lo acepta.

---

## 4. Errores de dominio personalizados y `DomainError`

En vez de usar errores genéricos (`ValueError`, `Exception`), el dominio define **sus propios errores**:

    class DomainError(Exception):
        pass

A primera vista parece inútil, pero es una **pieza clave**:

### 4.1. Es una “familia” de errores
Todas las excepciones del dominio heredan de esta clase:

    class SessionNotFound(DomainError): ...
    class SessionNotOpenForRegistration(DomainError): ...
    class SessionFull(DomainError): ...

Esto permite capturarlas TODAS en una sola instrucción:

    try:
        use_case.execute(...)
    except DomainError as e:
        return Response({"error": str(e)}, status=400)

### 4.2. ¿Por qué heredar si está vacía?

Porque **representa un tipo**, no una funcionalidad.

Metáfora:
Es el “apellido común” de todos los errores del dominio.
Si todos se apellidan *DomainError*, puedes filtrarlos juntos.

### 4.3. ¿Por qué pasamos argumentos a las excepciones?

Por ejemplo:

    raise SessionNotFound(session_id)

La clase recibe el ID para:

- construir un mensaje claro
- guardarlo internamente
- facilitar logs, debugging y respuestas HTTP

Ejemplo:

    class SessionNotFound(DomainError):
        def __init__(self, session_id):
            message = f"La sesión {session_id} no existe."
            super().__init__(message)
            self.session_id = session_id

Cuando haces:

    except SessionNotFound as e:
        e.session_id  # contiene el ID que falló

### 4.4. ¿Por qué usamos super().__init__(message)?

- Llama al constructor del padre (`Exception`)
- Registra el mensaje internamente
- Permite que `str(e)` muestre el mensaje

Sin esta llamada, la excepción saldría SIN mensaje.

---

## 5. ¿Qué son los repositorios In Memory y por qué `InMemorySessionRepository` puede heredar o NO heredar del `Protocol`?

Un repositorio es un objeto que desde el dominio parece ser una colección de entidades (sesiones, registros, etc):

    session = session_repo.get_session_by_id(1)
    session_repo.save_session(session)

pero cuyo contenido, en realidad, se está guardando en un almacenamiento externo (BD, API, ficheros...) pues está operando en
la infraestructura: ejecutar SQL, guardar un modelo Django, llamar una API, escribir un fichero, etc.

Los repositorios, normalmente, sólo tienen métodos. Dichos métodos serán operaciones de lectura/escritura sobre una colección
del dominio (get, lis_all, save, delete, etc). Los repositorios *in-memory* sí pueden tener atributos (dicionarios que simular una BD, contadores, etc)

Los repositorios *in-memory* son implementaciones “falsas” de los puertos del dominio.
Simulan lo que haría la infraestructura real (base de datos, Django ORM), pero usando únicamente estructuras de datos de Python — normalmente diccionarios. Sin servidor. Sin migraciones. Sin bases de datos. Sin modelos Django.

Ejemplo conceptual:

- `DjangoSessionRepository` → Adaptador REAL (usa la BD)
- `InMemorySessionRepository` → Adaptador FALSO (usa un dict)

Ambos cumplen el mismo **contrato** (`SessionRepository`), pero uno es real y otro es simulado.

Esto permite ejecutar casos de uso sin infraestructura, lo cual es ideal para tests rápidos y para la arquitectura hexagonal.

---

### 5.1. ¿Por qué estos repos in-memory son adaptadores?

En arquitectura hexagonal:

- El **dominio** depende de puertos (interfaces) que no implementan métodos.
- La **infraestructura** crea adaptadores que implementan esos puertos (implementan los métodos con infrastructura concreta: Django, HTTP, SQL, etc)

Ejemplo:

    SessionRepository (puerto)
         ▲
         │
    ┌────┴──────────────────────────────┐
    │                                   │
    DjangoSessionRepository       InMemorySessionRepository
 (adaptador real, ORM)        (adaptador falso, tests / desarrollo)

Ambos ofrecen los mismos métodos:

- `get_session_by_id`
- `save_session`

pero los ejecutan de forma diferente.

El caso de uso no nota la diferencia porque solo depende del **puerto**, no de la implementación.


| Infraestructura (real) | In-Memory (falso) |
| ---------------------- | ----------------- |
| Django ORM             | Diccionarios      |
| SQL                    | Listas Python     |
| Guardar modelo         | Guardar objeto    |
| Búsqueda por ID        | Buscar en dict    |
| Autoincrement ID       | Counter en Python |


---

### 5.2. Con `Protocol` el adaptador NO necesita heredar del puerto

El `Protocol` define una interfaz estructural:

> “Si una clase tiene estos métodos con estas firmas, ya cumple el contrato”.

Eso significa que esta clase:

    class InMemorySessionRepository:
        def get_session_by_id(self, session_id):
            ...
        def save_session(self, session):
            ...

YA cumple el contrato del protocolo **sin heredar nada**.

Python no exige herencia explícita como Java, C# o PHP.
Solo exige que la clase **tenga los métodos adecuados**.

Este mecanismo se llama **typing estructural** o “duck typing tipado”:

> Si camina como un pato y hace cuac como un pato, es un pato.

---

### 5.3. Entonces, ¿por qué A VECES heredamos del protocolo?

Principalmente por **intención y claridad visual**.

Ejemplo:

    class InMemorySessionRepository(SessionRepository):
        ...

Esto le dice al lector:

> “Esta clase implementa explícitamente el puerto `SessionRepository`.”

No cambia el comportamiento, no añade métodos, no ejecuta lógica del padre.
Solo sirve como **declaración de intención**.

Además:

- Ayuda a herramientas estáticas (mypy, pyright) a detectar errores de firma.
- Hace más evidente la relación adaptador → puerto.

Pero **NO ES OBLIGATORIO**.

---

### 5.4. ¿Qué pasa si no heredo?

Respuesta: **Nada. Funciona igual.**

    class InMemorySessionRepository:
        def get_session_by_id(self, session_id):
            ...
        def save_session(self, session):
            ...

El caso de uso podrá recibir esta clase exactamente igual:

    repo = InMemorySessionRepository()
    use_case = RegisterToSessionUseCase(repo, ...)

Porque cumple el contrato del protocolo al tener los métodos adecuados.

---

### 5.5. Comparación visual: herencia vs no herencia

**Con herencia (explícito, más declarativo):**

    class InMemorySessionRepository(SessionRepository):
        def get_session_by_id(self, session_id):
            return self._sessions.get(session_id)

        def save_session(self, session):
            self._sessions[session.id] = session

**Sin herencia (más estilo Python, más flexible):**

    class InMemorySessionRepository:
        def get_session_by_id(self, session_id):
            return self._sessions.get(session_id)

        def save_session(self, session):
            self._sessions[session.id] = session

Ambas versiones son 100% válidas.
La herencia solo cambia **cómo se lee el código**, no cómo funciona.



Un `Protocol` es como una **carta de requisitos** que dice:

- Debe tener método A.
- Debe tener método B.

Para cumplirla, puedes:

1. **Firmar la carta (heredar del protocolo)**
   → Más explícito, más formal.

2. **Cumplir la carta sin firmarla (no heredar)**
   → Python lo permite, mientras tengas los métodos adecuados.

Ambas formas son válidas.
La elección depende de estilo y claridad.



---

## 6. Resumen rápido para repaso

- **`default_factory`** → para valores dinámicos o mutables.
- **`@dataclass`** → para entidades (datos + reglas), NO para casos de uso.
- **`Protocol`** → define contratos; heredar es opcional.
- **`DomainError`** → clase base para capturar todos los errores del dominio.
- **Excepciones personalizadas** → transmiten contexto claro (session_id, etc.).
- **Repos in-memory** → funcionan aunque NO hereden del protocolo.

